<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Course Reflections</title>
    <link rel="shortcut icon" href="assets/favicon.png" type="image/x-icon">
    <link rel="stylesheet" href="reflection.css">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
</head>

<body>
    <header>
        <h1>Reflections of My Course(Design and analysis of algorithm)</h1>
        <p>A journey through learning and connecting concepts to real-world applications.</p>
    </header>

    <section>
        <h2>ðŸ“š What Was the Course About?</h2>
        <p>
            This course introduced me to the foundational principles of algorithm design, optimization,
            and problem-solving techniques. It helped me understand how to tackle complex computational challenges
            effectively and efficiently.
        </p>

        <h2>ðŸ”¢ Data Structures Studied</h2>
        <ul>
            <li>
                <strong>1.Binary Search Tree(BST):</strong> A binary search tree is a hierarchical data structure where
                nodes are arranged so that the left subtree contains smaller elements and the right subtree contains
                larger elements.
                <p>Visualizing tree structures and their dynamic updates during insertion and deletion.
                    Implementing self-balancing BSTs (e.g., AVL Trees) to maintain efficiency.
                    Handling edge cases like skewed trees where efficiency degrades to O(n). <br>
                    Difficulty in understanding how BSTs are used in databases for efficient data retrieval.
                    In dynamic datasets, maintaining a balanced BST is computationally expensive.
                    Real-world applications often involve advanced variants like B-Trees instead of simple BSTs. <br>
                    Use BSTs when quick insertions, deletions, and lookups are required in dynamic datasets.
                    If balancing is critical, use AVL or Red-Black trees for guaranteed O(log n) performance.
                    Example: When designing a range query system, a balanced BST ensures fast lookups.
                </p>
            </li>
            <li>
                <strong>2.DFS and BFS(Graph travesals):</strong> DFS explores nodes as deep as possible before
                backtracking, while BFS explores nodes level by level.
                <p>Understanding recursion in DFS and implementing it using stacks for iterative solutions.
                    Identifying when to use BFS or DFS depending on the problem (e.g., shortest path vs. connected
                    components). <br>
                    Applying BFS for shortest path problems in unweighted graphs and adapting it for real-world
                    scenarios like traffic routing.
                    Handling memory issues when using BFS for large graphs with high branching factors.
                    Understanding how DFS is used in topological sorting and other advanced graph algorithms. <br>
                    Use BFS for shortest path problems or scenarios requiring exploration level by level.
                    Use DFS for backtracking problems (e.g., solving mazes) or detecting cycles in graphs.
                    Example: BFS can be used in social network applications to find the shortest path between two users.
                </p>
            </li>
            <li>
                <strong>3.Heap:</strong> A heap is a binary tree-based structure that maintains the heap property, where
                the root is the minimum (min-heap) or maximum (max-heap) element.
                <p>Visualizing heap construction using array representation can be difficult.
                    Implementing heaps manually, especially for dynamic insertions and deletions.
                    Understanding heapify operations and their time complexities (O(log n)). <br>Using heaps in
                    scenarios requiring frequent updates, like real-time scheduling.
                    Optimizing heap-based priority queues for massive datasets.
                    Adapting heap properties for non-traditional use cases, like approximate searching. <br>Use heaps
                    for scenarios requiring frequent access to the smallest or largest elements (e.g., priority queues).
                    Pair heaps with other data structures (e.g., hash maps) to improve performance in complex
                    applications.
                    Example: In event scheduling systems, min-heaps ensure efficient task prioritization.</p>
            </li>
            <li>
                <strong>4.Sorting Algorithms:</strong> Sorting involves arranging data in a particular order (ascending
                or descending). Algorithms like quicksort, mergesort, and bubble sort are common.
                <p>Memorizing the time complexities and stability of different algorithms.
                    Understanding recursive approaches like mergesort and quicksort.
                    Debugging sorting implementations, especially in-place algorithms like quicksort. <br>Selecting the
                    best sorting algorithm for specific datasets (e.g., small vs. large data).
                    Handling real-world constraints like memory limits, which make in-place sorting critical.
                    Optimizing sorting in distributed systems (e.g., map-reduce sorting).
                    <br>Use quicksort for general-purpose, in-place sorting.
                    Use mergesort when stable sorting is required.
                    Example: E-commerce platforms use efficient sorting to display products by price or ratings.
                </p>
            </li>
            <li>
                <strong>5.Pattern Searching:</strong> Algorithms like KMP and Rabin-Karp search for substrings
                efficiently within larger strings.
                <p>Grasping advanced preprocessing techniques like partial match tables in KMP.
                    Debugging pattern-matching algorithms with overlapping substrings.
                    Understanding the trade-offs between naive and optimized approaches. <br>Implementing pattern
                    searching in large-scale applications like search engines.
                    Adapting algorithms to handle noisy data or approximate matches (e.g., DNA sequencing).
                    Optimizing performance for streaming data.
                    <br>Use naive algorithms for small datasets.
                    Use KMP or Rabin-Karp for larger datasets requiring preprocessing.
                    Example: Search engines use pattern searching to index and retrieve relevant documents.
                </p>
            </li>
            <li>
                <strong>6.Graph Algorithms:</strong> Algorithms for solving graph problems include Dijkstraâ€™s (shortest
                path), Kruskalâ€™s (MST), etc.
                <p>Understanding graph representations (adjacency matrix vs. adjacency list).
                    Debugging infinite loops or incorrect results due to unhandled edge cases.
                    Implementing complex algorithms like Dijkstraâ€™s with priority queues.
                    <br>Scaling graph algorithms to handle large datasets in social networks or transport systems.
                    Adapting algorithms to work on dynamic graphs where edges or weights change frequently.
                    Optimizing for distributed graph processing (e.g., in Google Maps). <br>Use Dijkstraâ€™s for weighted,
                    single-source shortest paths; use BFS for unweighted graphs.
                    Optimize MST algorithms based on edge density (Kruskalâ€™s for sparse, Primâ€™s for dense graphs).
                    Example: Dijkstraâ€™s algorithm is used in GPS navigation systems for route optimization.
                </p>
            </li>
        </ul>

        <h2>ðŸŒŸ Connecting the Course to Real-Time Applications</h2>
        <p>
            By applying the concepts learned in this course, I developed a <strong>Parking Management System</strong>,
            which utilizes graph algorithms to find the nearest parking spot based on user location.
            This real-world application highlights the power of data structures and algorithms in solving practical
            problems.
        </p>
    </section>
</body>

</html>